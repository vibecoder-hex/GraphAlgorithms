# Алгоритмы на графах(для reamap)

1. Поиск в ширину (BFS — Breadth-First Search)
Основная идея: Обход графа "по слоям". Сначала посещаются все соседи начальной вершины, затем соседи соседей и так далее.

Как работает:

Начать с исходной вершины, пометить её как посещённую и поместить в очередь (Queue) — структуру данных FIFO (First In, First Out).

Пока очередь не пуста:

Извлечь вершину из начала очереди.

Обработать её (например, найти целевую вершину).

Добавить в очередь всех ещё не посещённых соседей этой вершины и пометить их как посещённые.

Ключевые свойства:

Гарантированно находит кратчайший путь в невзвешенном графе (по количеству рёбер).

Работает на графах и деревьях.

Требует много памяти, так как хранит в памяти все вершины текущего "слоя".

Сложность: O(V + E), где V — вершины, E — рёбра.

Где применяется:

Поиск кратчайшего пути в лабиринте или соцсети (когда "стоимость" всех связей одинакова).

Построение индексов для поисковых систем (обход "в ширину" от стартовой страницы).

Нахождение связных компонентов в графе.

Алгоритмы на графах (например, для проверки двудольности).

2. Поиск в глубину (DFS — Depth-First Search)
Основная идея: Идти "вглубь" графа насколько это возможно, возвращаясь назад (backtracking), когда путь ends.

Как работает (рекурсивный вариант):

Начать с исходной вершины, пометить её как посещённую.

Для каждого не посещённого соседа этой вершины:

Рекурсивно вызвать DFS от этого соседа.

Также может быть реализован с использованием стека (Stack) — структуры данных LIFO (Last In, First Out).

Ключевые свойства:

Не находит кратчайший путь (может найти любой путь до цели).

Требует меньше памяти, чем BFS, так как хранит только путь от корня до текущей вершины (O(h), где h — высота/глубина).

Может зациклиться на графах с циклами, если не использовать метки посещения.

Полезен для задач, где нужно проверить все возможные варианты (полный обход).

Сложность: O(V + E).

Где применяется:

Поиск цикла в графе.

Проверка связности графа.

Топологическая сортировка (для DAG — Directed Acyclic Graphs).

Решение головоломок (например, лабиринт, где нужно найти любой выход).

Поиск сильно связных компонентов (алгоритм Косарайю или Тарьяна).

3. Алгоритм Дейкстры (Dijkstra's Algorithm)
Основная идея: Нахождение кратчайших путей от одной стартовой вершины до всех остальных в взвешенном графе с неотрицательными весами рёбер.

Как работает (жадный алгоритм):

Присвоить начальной вершине расстояние 0, а всем остальным — бесконечность.

Поместить все вершины в приоритетную очередь (Min-Heap) по текущему расстоянию.

Пока очередь не пуста:

Извлечь вершину u с минимальным текущим расстоянием.

Для каждого соседа v вершины u:

Вычислить новое расстояние: расстояние_до_u + вес_ребра(u, v).

Если это расстояние меньше текущего известного расстояния до v, то обновить расстояние до v и запомнить u как предшественника v (для восстановления пути).

Повторять, пока не будут обработаны все вершины.

Ключевые свойства:

Работает только с неотрицательными весами рёбер. Отрицательные веса нарушают его логику.

Гарантированно находит оптимальные кратчайшие пути.

Сложность зависит от реализации структуры данных:

С массивом: O(V² + E) — хорошо для плотных графов.

С бинарной кучей (приоритетной очередью): O((V + E) log V) — лучше для разреженных графов.

С более продвинутыми кучами (Фибоначчи) можно улучшить до O(E + V log V).

Где применяется:

Маршрутизация в сетях (протоколы типа OSPF, IS-IS).

Построение карт и навигация (поиск кратчайшего пути по времени или расстоянию).

Моделирование потоков.

Как основа для более сложных алгоритмов (например, A* с эвристикой).
